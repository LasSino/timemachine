# frozen_string_literal: true

require 'thread_executor'

#
# Namespace TimeMachine contains all the magics of this gem.
#
module TimeMachine

  #
  # The internal struct to store a task.
  #
  TimedTask = Struct.new(:handle, :timeup, :block)

  #
  # The struct to store the result of a task.
  #
  TaskResult = Struct.new(:handle, :status, :record_result, :result)

  #
  # `DuplicateHandleError` is thrown when the handle (name) for a new task collides with a existing one.
  #
  class DuplicateHandleError < RuntimeError; end

  #
  # The core of this gem, which is responsible for scheduling tasks.
  #
  class TimeMachine
    # Default timeout of the scheduler, used when the scheduler is idle.
    SCHEDULER_DEFAULT_TIMEOUT = 3

    # Length of the handle generated by `TimeMachine`.
    RANDOM_HANDLE_LENGTH = 16

    private_constant :SCHEDULER_DEFAULT_TIMEOUT

    public
    #
    # Create a new `TimeMachine`.
    #
    # @param [Executors::Executor] executor The task executor to be used. Defaults to a `Executors::ThreadExecutor`.
    # @param [Boolean] more_timely Use a lock in scheduler. This theoretically makes the tasks executed more timely
    #   in certain cases. However, considering GIL, there will be no substantial difference, and the additional
    #   locking steps may even slow the program down.
    #
    def initialize(executor= Executors::ThreadExecutor.new, more_timely=false)
      @running = false
      @timeout_queue = []

      @result_queue = {}
      @pending_schedule_queue = []
      @cancel_queue = []

      @executor = executor
      @scheduler_thread = nil
      @scheduler_mut = if more_timely then Mutex.new else nil end
      @user_mut = Mutex.new
    end

    #
    # Execute the given block at the given timeup.
    #
    # @param [Time] timeup The time to invoke the given block
    # @param [String] name A custom name (handle) for the task. If `nil`, one will be generated. If specified,
    #   should not be duplicate with an existing one.
    # @param [Boolean] record_result Whether to save the result after completion.
    # @param [Proc] &block The block to execute.
    #
    # @return [String] A handle to the task, either the name passed in (if given) or generated by `TimeMachine`.
    #   Can be used to cancel the task or query task status and result (if `record_result` is set).
    #
    def at(timeup, name: nil, record_result: false, &block)
      handle = name || _generate_handle

      @user_mut.synchronize do
        raise DuplicateHandleError if @result_queue.key? handle
        result_slot = TaskResult.new(handle, :UNSCHEDULED, record_result, nil)
        @result_queue[handle] = result_slot
        @pending_schedule_queue << TimedTask.new(
          handle, timeup, block
        )
      end

      _bg_wakeup
      handle
    end

    #
    # Execute the given block after given timeout.
    #
    # @param [Float] timeout Timeout in seconds.
    # @param [String] name A custom name (handle) for the task. If `nil`, one will be generated. If specified,
    #   should not be duplicate with an existing one.
    # @param [Boolean] record_result Whether to save the result after completion.
    # @param [Proc] &block The block to execute.
    #
    # @return [String] A handle to the task, either the name passed in (if given) or generated by `TimeMachine`.
    #   Can be used to cancel the task or query task status and result (if `record_result` is set).
    #
    def after(timeout, name: nil, record_result: false, &block)
      at(Time.now + timeout, name: name, record_result: record_result, &block)
    end

    #
    # Get the result of a given block.
    #
    #
    # @param [String] handle The handle to the task, typically returned by previous `at` and `after` calls.
    #
    # @return [TaskResult] The result of the given task. If not found, or the task is finished with `record_result`
    #   unset, returns `nil`.
    #
    def get_result(handle)
      @user_mut.synchronize do
        @result_queue[handle]
      end
    end

    #
    # Get the result of a given block, and delete it from `TimeMachine`'s internal storage if it is finished or cancelled.
    # *Remember to call this, or the results will pile up and eat your memory!*
    #
    # @param [String] handle The handle to the task, typically returned by previous `at` and `after` calls.
    #
    # @return [TaskResult] The result of the given task. If not found, or the task is finished with `record_result`
    #   unset, returns `nil`. If the task is finished or cancelled, it will be deleted from `TimeMachine` storage as well.
    #
    def pop_result(handle)
      @user_mut.synchronize do
        res = @result_queue[handle]
        if res&.status==:FINISHED || res&.status==:CANCELLED
          @result_queue.delete(handle)
        else
          res
        end
      end
    end

    #
    # Cancel a previously submitted task.
    # Be sure to cancel it in time if you mean to cancel it.
    # *If the task has already been scheduled or executed, cancel may not take effect.*
    #
    # @param [String] handle The handle to the task, typically returned by previous `at` and `after` calls.
    #
    def cancel(handle)
      @user_mut.synchronize do
        @cancel_queue << handle
      end
      _bg_wakeup
    end

    #
    # Start the `TimeMachine`. This will create a background scheduler thread.
    #
    def start()
      @user_mut.synchronize do
        return if @running
        @running = true
        @scheduler_thread = Thread.new { _bg_run() }
      end
    end

    #
    # Stop the `TimeMachine`. All tasks due after this call will be cancelled.
    #
    def stop()
      @user_mut.synchronize do
        return unless @running
        @running = false
        @result_queue.each_key { |h| @cancel_queue << h}
      end
      _bg_wakeup
    end

    private
    def _generate_handle
      h = (Time.now.to_f * 1000).to_i.to_s(36)
      padding_len = RANDOM_HANDLE_LENGTH - h.size
      randstr = Random.rand(('z'*padding_len).to_i(36))
                  .to_s(36).rjust(padding_len, '0')
      h + randstr
    end

    def _bg_wakeup
      @scheduler_mut&.lock
      @scheduler_thread&.run
      @scheduler_mut&.unlock
    end

    def _bg_run
      @scheduler_mut&.lock
      while @running
        @user_mut.synchronize do
          @cancel_queue.each { |h| _bg_cancelTask(h) }
          @cancel_queue.clear
          @pending_schedule_queue.each { |t| _bg_enqueueTask(t) }
          @pending_schedule_queue.clear
        end

        abs_t = Time.now
        ind = @timeout_queue.index { |t| t.timeup > abs_t } || @timeout_queue.size

        @timeout_queue[0...ind].each do |t|
          break if !@running
          _bg_dispatchTask(t)
        end

        @timeout_queue = @timeout_queue[ind..]

        timeout = (
          @timeout_queue[0]&.timeup || 
          (abs_t + SCHEDULER_DEFAULT_TIMEOUT)
        ) - abs_t
        timeout = 0 if timeout < 0

        @scheduler_mut&.unlock
        sleep timeout
        @scheduler_mut&.lock        
      end
      @scheduler_mut&.unlock
      @scheduler_thread = nil
    end

    def _bg_enqueueTask(task)
      return if @result_queue[task.handle].status != :UNSCHEDULED

      @result_queue[task.handle].status = :PENDING
      @timeout_queue.insert(@timeout_queue.index do |t|
        t.timeup > task.timeup
      end || -1, task)
    end

    def _bg_cancelTask(handle)
      result_slot = @result_queue[handle]
      case result_slot&.status
      when :UNSCHEDULED
        result_slot.status = :CANCELLED
      when :PENDING
        result_slot.status = :CANCELLED
        @timeout_queue.delete_if do |task|
          task.handle == handle
        end
      end

      @result_queue.delete(handle) unless result_slot&.record_result
    end

    def _bg_dispatchTask(task)
      return if !@running
      result_slot = @result_queue[task.handle]
      return if result_slot&.status != :PENDING

      result_slot.status = :RUNNING
      @executor.execute do
        result_slot&.result = task.block.call
        @user_mut.synchronize {
          result_slot.record_result ? (result_slot&.status = :FINISHED) : @result_queue.delete(task.handle)
        }
      end
    end
  end
  
end
